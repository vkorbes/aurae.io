{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aurae Runtime Aurae is a low level distributed runtime system built for application and platform teams to run and manage multi tenant workloads. Read the motivation: Why fix Kubernetes and Systemd? Contribute to the original architecture: Open Access Whitepaper Multi Tenant Nodes Aurae aims to be a simplified alternative to many of the features in systemd . Aurae also goes after the scope of the kubernetes kubelet in the hopes of building a multi tenant node daemon. Namespaces run in VMs Aurae serves as the hypervisor. Aurae will manage the VM metadata on a single machine. Aurae wants to pursue multi tenant semantics in distributed systems such as Kubernetes. Aurae accomplishes this by running namespace workloads directly in lightweight virtual machines for an additional layer of isolation. Aurae and Container Runtimes Aurae will schedule lightweight containers without the need to manage an additional container runtime. Just install Aurae and begin running OCI container images. Aurae Language Aurae offers an alternative to Kubernetes YAML by baking in a Turing complete interpretted language specifically for interfacing with the backend daemon. #!/usr/bin/env aurae // Connect and authenticate with a local Daemon let aurae = connect (); aurae . info (); // Get the status of the daemon let observe = aurae . obsever () observe . status () Get Involved Join the Aurae Community to get involved! Read The Paper We are tracking our original architecture paper where we welcome contributions and thoughts on the approach. Learn about the philosophy, motivation, and first principles.","title":"Home"},{"location":"#aurae-runtime","text":"Aurae is a low level distributed runtime system built for application and platform teams to run and manage multi tenant workloads. Read the motivation: Why fix Kubernetes and Systemd? Contribute to the original architecture: Open Access Whitepaper","title":"Aurae Runtime"},{"location":"#multi-tenant-nodes","text":"Aurae aims to be a simplified alternative to many of the features in systemd . Aurae also goes after the scope of the kubernetes kubelet in the hopes of building a multi tenant node daemon. Namespaces run in VMs Aurae serves as the hypervisor. Aurae will manage the VM metadata on a single machine. Aurae wants to pursue multi tenant semantics in distributed systems such as Kubernetes. Aurae accomplishes this by running namespace workloads directly in lightweight virtual machines for an additional layer of isolation.","title":"Multi Tenant Nodes"},{"location":"#aurae-and-container-runtimes","text":"Aurae will schedule lightweight containers without the need to manage an additional container runtime. Just install Aurae and begin running OCI container images.","title":"Aurae and Container Runtimes"},{"location":"#aurae-language","text":"Aurae offers an alternative to Kubernetes YAML by baking in a Turing complete interpretted language specifically for interfacing with the backend daemon. #!/usr/bin/env aurae // Connect and authenticate with a local Daemon let aurae = connect (); aurae . info (); // Get the status of the daemon let observe = aurae . obsever () observe . status ()","title":"Aurae Language"},{"location":"#get-involved","text":"Join the Aurae Community to get involved!","title":"Get Involved"},{"location":"#read-the-paper","text":"We are tracking our original architecture paper where we welcome contributions and thoughts on the approach. Learn about the philosophy, motivation, and first principles.","title":"Read The Paper"}]}